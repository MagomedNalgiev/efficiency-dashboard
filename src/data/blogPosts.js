// src/data/blogPosts.js

export const blogPosts = [
  {
    id: 1,
    slug: 'velocity-komanda-razrabotki',
    title: 'Как правильно измерять Velocity команды разработки',
    category: 'Agile',
    excerpt: 'Velocity — ключевая метрика в Agile-разработке. Разбираем, как правильно рассчитывать и интерпретировать результаты.',
    content: `
# Как правильно измерять Velocity команды разработки

Velocity — это показатель объема работы, который команда выполняет за спринт, выраженный в story points. Он помогает прогнозировать сроки и учитывать возможности команды.

## Зачем измерять Velocity

1. Планирование. Зная средний Velocity, можно более точно оценить, сколько работы команда успеет выполнить за будущий спринт.
2. Мониторинг прогресса. Изменение Velocity может сигнализировать о проблемах или улучшениях в процессе.
3. Ожидания стейкхолдеров. Реальные данные об объеме работы повышают доверие к оценкам.

## Как рассчитывать Velocity

1. Определите метрику story points для всех задач в спринте.
2. Подсчитайте story points только по полностью завершенным задачам.
3. Сложите их — это Velocity спринта.
4. Повторите за несколько спринтов, чтобы получить средний Velocity.

\`\`\`
Velocity = Σ (story points завершенных задач)
\`\`\`

## Рекомендации по использованию

- Рассчитывайте среднюю Velocity за 3–5 последних спринтов.
- Не сравнивайте Velocity разных команд — у каждой свои условия.
- Обновляйте story points и Velocity регулярно, чтобы данные оставались актуальными.
- Используйте Velocity как инструмент планирования, а не KPI для давления на команду.

## Частые ошибки

- Учитывать незавершенные истории.
- Изменять story points во время спринта.
- Сравнивать Velocity до и после значительных изменений в команде.

---

# Заключение

Velocity — простой и мощный инструмент Agile-команд. Его фундаментальная ценность в том, что метрика базируется на собственных данных команды, а не на внешних ожиданиях.
    `,
    date: '01.10.2025',
    readTime: '5 мин',
    author: 'Magomed Nalgiev'
  },
  {
    id: 2,
    slug: 'mttr-vosstanovlenie-kritichno',
    title: 'MTTR: Почему время восстановления критично для бизнеса',
    category: 'DevOps',
    excerpt: 'MTTR (Mean Time to Recovery) — показатель скорости восстановления сервиса после сбоя. Изучаем ключевые практики снижения MTTR.',
    content: `
# MTTR: Почему время восстановления критично для бизнеса

Mean Time to Recovery (MTTR) показывает среднее время, за которое система восстанавливается после инцидента. Для бизнеса быстрый отклик на сбои важен для удержания пользователей и минимизации потерь.

## Компоненты MTTR

1. **Время обнаружения инцидента**
2. **Время диагностики причины**
3. **Время разработки и проверки исправления**
4. **Время развертывания и валидации решения**

\`\`\`
MTTR = Время восстановления / Количество инцидентов
\`\`\`

## Почему MTTR важен

- **Доверие пользователей.** Быстрое восстановление снижает негативный опыт.
- **Финансовые потери.** Каждый час простоя — прямые убытки для e-commerce и SaaS.
- **Репутация бренда.** Публичные сбои распространяются в СМИ и соцсетях.

## Как снизить MTTR

1. **Автоматизация мониторинга и алертинга**
   Непрерывный сбор метрик и мгновенные уведомления ускоряют обнаружение проблем.
2. **Готовые runbook-ы**
   Подробные инструкции по быстрому устранению типовых инцидентов.
3. **Blue/Green-развертывания и Canary-релизы**
   Позволяют тестировать обновления безопасно и быстро откатиться при ошибках.
4. **Chaos Engineering**
   Регулярные эксперименты помогают выявить узкие места до продакшн-сбоев.
5. **RBAC и автоматическое восстановление**
   Правильные права доступа и скрипты для автоперезапуска сервисов.

## Метрики для контроля

- Частота инцидентов (Incident Count)
- Среднее время до обнаружения (MTTD)
- Уровень повторных инцидентов
- Процент времени безотказной работы (Uptime %)

---

# Итог

MTTR — ключевой показатель надежности систем. Снижение MTTR достигается путем автоматизации, подготовки инструкций и регулярного тестирования.
    `,
    date: '28.09.2025',
    readTime: '7 мин',
    author: 'Magomed Nalgiev'
  }
]

export const getBlogPost = (slug) => {
  return blogPosts.find(post => post.slug === slug)
}
